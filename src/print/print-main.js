(async function main() {
  try {
    const { loadPrintSettings, el, a } = window.__PRINT_UTILS__;
    const { renderHeader } = window.__PRINT_RENDER_HEADER__;
    const R = window.__PRINT_RENDER_SECTIONS__;
    const { finalGlobalPhraseDedup } = window.__PRINT_FINALIZE__;

    const params = new URLSearchParams(location.search);
    const nonce = params.get('nonce') || '';
    const isDebug = params.has('debug') && params.get('debug') === '1';

    if (!nonce) {
      if (isDebug) console.error('[print] Missing ?nonce');
      return;
    }

    function readInlinePayloadFromHash() {
      try {
        const h = location.hash || '';
        const m = h.match(/[#&]p=([A-Za-z0-9\-_]+)/);
        if (!m) return null;
        const b64url = m[1].replace(/-/g, '+').replace(/_/g, '/');
        const pad =
          b64url.length % 4 ? '='.repeat(4 - (b64url.length % 4)) : '';
        const json = decodeURIComponent(escape(atob(b64url + pad)));
        const obj = JSON.parse(json);
        if (obj && typeof obj === 'object' && (obj.data || obj.profile)) {
          return obj.data ? obj : { data: obj.profile, settings: obj.settings };
        }
      } catch (e) {
        if (isDebug) console.warn('[print] Inline payload parse error:', e);
      }
      return null;
    }

    async function getPayloadWithRetry(key, attempts = 10, delayMs = 100) {
      for (let i = 0; i < attempts; i++) {
        const store = await new Promise((res) =>
          chrome.storage.local.get(key, res)
        );
        if (store && store[key]) return store[key];
        await new Promise((r) => setTimeout(r, delayMs));
      }
      return null;
    }

    let payload = readInlinePayloadFromHash();
    if (!payload) {
      payload = await getPayloadWithRetry(nonce);
    }
    if (!payload) {
      if (isDebug)
        console.error('[print] No payload for nonce after retry:', nonce);
      const rootEmpty = document.getElementById('root');
      if (rootEmpty) rootEmpty.append(el('p', '', 'No data to render.'));
      return;
    }

    const profile = payload.data || payload.profile || {};
    const saved = await loadPrintSettings().catch(() => ({}));
    const settings = { ...saved, ...(payload.settings || {}) };

    if (isDebug) console.log('[print] Loaded payload:', { profile, settings });

    const root = document.getElementById('root');

    if (isDebug)
      console.log(
        '[print] Before renderHeader — images:',
        document.images.length
      );
    if (settings.profileHeader !== false) renderHeader(root, profile, settings);
    if (isDebug)
      console.log(
        '[print] After renderHeader — images:',
        document.images.length
      );

    if (settings.contact) R.renderContact(root, profile);
    if (settings.about) R.renderAbout(root, profile);
    if (settings.experience) R.renderExperience(root, profile);
    if (settings.education) R.renderEducation(root, profile);
    if (settings.certifications) R.renderCertifications(root, profile);
    if (settings.skills) R.renderSkills(root, profile);
    if (settings.languages) R.renderLanguages(root, profile);
    if (settings.honors) R.renderHonors(root, profile);
    if (settings.publications) R.renderPublications(root, profile);
    if (settings.interests) R.renderInterests(root, profile);

    const footer = el('footer', '');
    footer.append(
      document.createTextNode('Generated by LinkedIn Save to PDF — Author: '),
      a(
        'https://www.linkedin.com/in/fmrodrigo/',
        'Franco Mariano Rodrigo (Ingenarte)'
      ),
      document.createTextNode(' — '),
      a(
        'https://github.com/Ingenarte/Linkedin_Save_to_PDF',
        'https://github.com/Ingenarte/Linkedin_Save_to_PDF'
      )
    );
    root.append(footer);

    // --- PROTECT HEADER FROM DEDUP ---
    const headerSection = root.querySelector('section.header');
    let headerPlaceholder = null;
    if (headerSection) {
      headerPlaceholder = document.createComment('HEADER_PLACEHOLDER');
      root.replaceChild(headerPlaceholder, headerSection);
    }

    if (isDebug)
      console.log('[print] Before dedup — images:', document.images.length);
    finalGlobalPhraseDedup(root); // dedup only on body without header
    if (isDebug)
      console.log(
        '[print] After dedup (no header) — images:',
        document.images.length
      );

    if (headerPlaceholder) {
      root.replaceChild(headerSection, headerPlaceholder);
      if (isDebug)
        console.log(
          '[print] Header restored — images:',
          document.images.length
        );
    }
    chrome.storage.local.remove(nonce, () => {
      if (isDebug && chrome.runtime.lastError) {
        console.warn(
          '[print] chrome.storage.local.remove error:',
          chrome.runtime.lastError
        );
      }
    });

    async function waitForImages(container, timeoutMs = 8000) {
      const imgs = Array.from(container.querySelectorAll('img'));
      const pending = imgs.filter(
        (img) => !img.complete || img.naturalWidth === 0
      );

      if (isDebug) {
        console.log('[print] waitForImages — total imgs:', imgs.length);
        console.log('[print] waitForImages — pending imgs:', pending.length);
      }

      const decodePromises = pending.map((img) => {
        if (typeof img.decode === 'function') {
          return img.decode().catch(() => undefined);
        }
        return new Promise((res) => {
          const done = () => {
            img.removeEventListener('load', done);
            img.removeEventListener('error', done);
            res();
          };
          img.addEventListener('load', done);
          img.addEventListener('error', done);
        });
      });

      await Promise.race([
        Promise.all(decodePromises),
        new Promise((res) => setTimeout(res, timeoutMs)),
      ]);
    }

    try {
      if (document.fonts && document.fonts.ready) {
        await document.fonts.ready;
      }
    } catch {}

    await waitForImages(root, 8000);

    if (!isDebug) {
      window.print();
    } else {
      console.log(
        '[print] Debug mode enabled — print() not called automatically.'
      );
      console.log(
        '[print] Images status:',
        [...document.images].map((i) => ({
          src: i.src,
          complete: i.complete,
          naturalSize: [i.naturalWidth, i.naturalHeight],
        }))
      );
    }
  } catch (err) {
    console.error('[print] Fatal error in main()', err);
  }
})();
